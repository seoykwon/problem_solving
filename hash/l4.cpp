/*****************************************
 * 힌트에서 말하는 "공룡들의 나이가 1억이 넘기에 배열에 바로 담을 수 없습니다"라는 의미는, 공룡의 나이를 배열의 인덱스로 사용하기 어려움을 의미합니다.

일반적으로, 만약 우리가 나이를 배열의 인덱스로 직접 사용하려고 한다면, 예를 들어 arr[1000000005]처럼 매우 큰 인덱스를 사용해야 합니다. 하지만 배열의 인덱스는 크기에 제한이 있으며, 1억 이상의 인덱스를 가진 배열을 생성하는 것은 메모리적으로 비효율적입니다.

해결 방법: Hash Map과 Hash Function
이 문제를 해결하기 위해 해시 테이블(혹은 unordered_map을 통해)과 해시 함수(Hash Function)를 사용하여 다음과 같이 접근할 수 있습니다:

나이를 키(Key), **공룡 이름을 값(Value)**으로 하는 unordered_map을 사용합니다. 해시 함수는 입력된 나이를 특정 해시 버킷(bucket)으로 변환해 unordered_map에 저장하는 역할을 합니다.

사용자가 나이를 입력하면, 해당 나이를 unordered_map에서 키로 사용해 바로 공룡 이름을 찾을 수 있습니다. 이 방법은 메모리를 효율적으로 사용하면서 빠른 검색을 가능하게 합니다.

예시
예를 들어, 공룡 나이가 1000000005라면 배열로 구현할 경우 arr[1000000005]에 값을 저장해야 해서 큰 메모리 공간이 필요합니다.
하지만 unordered_map을 사용하면 dinosaurDB[1000000005] = "Sour";처럼 공룡 나이와 이름을 간단히 저장할 수 있습니다.
이 방법을 통해 공룡의 나이와 이름을 메모리 효율적으로 저장하고 빠르게 검색할 수 있습니다.
******************************************/

#include <iostream>
#include <unordered_map>
#include <string>

using namespace std;

int main()
{
    // 공룡 나이와 이름을 해시 맵에 저장
    unordered_map<long long, string> dinosaurDB = {
        {1000000005, "Sour"},
        {1000000002, "Dav"},
        {1000000003, "Nica"},
        {1000000006, "Timer"},
        {1000000015, "Pico"},
        {1000000022, "Topisl"},
        {1000000013, "Whab"},
        {1000000009, "Hap"}};

    freopen("input.txt", "r", stdin);
    // 사용자로부터 공룡 나이 입력 받기
    long long age;
    cin >> age;

    // 해시 맵에서 해당 나이에 맞는 공룡 이름 검색
    if (dinosaurDB.find(age) != dinosaurDB.end())
    {
        cout << dinosaurDB[age] << endl;
    }
    else
    {
        cout << "해당 나이에 맞는 공룡이 없습니다." << endl;
    }

    return 0;
}
